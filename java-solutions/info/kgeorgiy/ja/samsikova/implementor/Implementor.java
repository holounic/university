package info.kgeorgiy.ja.samsikova.implementor;

import info.kgeorgiy.java.advanced.implementor.ImplerException;
import info.kgeorgiy.java.advanced.implementor.JarImpler;
import javax.tools.JavaCompiler;
import javax.tools.ToolProvider;
import java.io.BufferedWriter;
import java.io.File;
import java.io.IOException;
import java.lang.reflect.*;
import java.net.URISyntaxException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.jar.JarOutputStream;
import java.util.stream.Collectors;
import java.util.zip.ZipEntry;

/**
 * Code generator, implementation of {@link info.kgeorgiy.java.advanced.implementor.JarImpler} interface.
 * Generate {@code .java} and {@code .jar} files, extending the provided {@code .Class}
 * or {@code Interface}.
 *
 * @see JarImpler
 * @see DirectoryUtils
 */
public class Implementor implements JarImpler {

    /**
     * Suffix, defining the name of the resulting class.
     */
    private static final String SUFFIX = "Impl";
    /**
     * String representation of {@code class} keyword.
     */
    private static final String CLASS = "class";
    /**
     * Line separator of the current system.
     */
    private static final String LINE_SEPARATOR = System.lineSeparator();
    /**
     * Exception prefix.
     */
    private static final String EXCEPTION_COMMON = "E Nonono: ";
    /**
     * Delimiter for methods and constructors arguments.
     */
    private static final String ARG_DELIMITER = ", ";
    /**
     * Jar mode keyword.
     */
    private static final String JAR_MODE = "--jar";
    /**
     * Watermark applied to each generated file.
     */
    private static final String WATERMARK = "// Generated by Masha Samsikova";
    /**
     * Tabulation string.
     */
    private static final String TAB = "\t";

    /**
     * Default constructor. Creates a new instance of {@code Implementor}.
     */
    public Implementor() {}

    /**
     * {@inheritDoc}
     */
    @Override
    public void implement(Class<?> token, Path root) throws ImplerException {
        if (unimplementable(token)) {
            throw new ImplerException(EXCEPTION_COMMON + "Provided unimplementable token");
        }
        Path dest;
        try {
            dest = getFullPath(root, token);
        } catch (Exception e) {
            throw new ImplerException("");
        }
        if (!DirectoryUtils.create(dest)) {
            throw new ImplerException("baad");
        }
        String packageName = token.getPackageName();
        String code = implementWaterMark() + implementPackageName(packageName) + implement(token);
        try (BufferedWriter writer = Files.newBufferedWriter(dest)) {
            writer.write(encode(code));
        } catch (IOException e) {
            e.printStackTrace();
            throw new ImplerException(EXCEPTION_COMMON + "Error opening file");
        }
    }


    /**
     * Creates {@code String} representation of the genrated class.
     *
     * @param token type token to create implementation for
     * @return {@code String} representation of the generated class
     * @throws ImplerException when implementation cannot be generated
     */
    private String implement(Class<?> token) throws ImplerException {
        StringBuilder classBuilder = new StringBuilder();
        classBuilder.append(implementName(token)).append(" {").append(LINE_SEPARATOR);
        if (!token.isInterface()) {
            classBuilder.append(implementConstructors(token));
        }

        for (Method method : getMethodsToImplement(token)) {
            classBuilder.append(implementMethod(method));
        }

        classBuilder.append("}");
        return classBuilder.toString();
    }

    /**
     * {@inheritDoc}
     */
    public void implementJar(Class<?> token, Path path) throws ImplerException {
        if (!DirectoryUtils.create(path)) {
            throw new ImplerException(EXCEPTION_COMMON + "unable to create directory");
        }
        Path tempPath = DirectoryUtils.createTemporal(path.toAbsolutePath().getParent());
        if (tempPath == null) {
            throw new ImplerException(EXCEPTION_COMMON + "unable to create temporal directory");
        }
        try {
            implement(token, tempPath);
            compileJava(token, tempPath);
            createJar(token, path, tempPath);
        } finally {
            DirectoryUtils.clear(tempPath);
        }
    }

    /**
     * @param token type token to get class path of
     * @return {@code String} representation of the tokens classpath
     */
    private String getClassPath(Class<?> token) {
        try {
            return Path.of(token.getProtectionDomain().getCodeSource().getLocation().toURI()).toString();
        } catch (URISyntaxException e) {
            throw new AssertionError(e);
        }
    }

    /**
     * @param token type token to get package directory of
     * @param separator path separator
     * @return {@code String} representation of package directory
     */
    private String getPackageDir(Class<?> token, String separator) {
        return token.getPackageName().replace(".", separator);
    }

    /**
     * Invokes {@link #getPackageDir(Class, String)} by passing the provided token and standard file separator.
     * @param token type token to get package directory of
     * @return {@code String} representation of package directory
     */
    private String getPackageDir(Class<?> token) {
        return getPackageDir(token, File.separator);
    }

    /**
     * Returns the name of {@code token} implementation class.
     *
     * @param token type token of the parental instance
     * @return {@code String} representation of the nam eof the class
     */
    private String getClassName(Class<?> token) {
        return token.getSimpleName() + SUFFIX;
    }

    /**
     * Returns the full path to {@code .java} file considering the {@code root} and {@code token} package.
     *
     * @param root  root directory
     * @param token type token to create implementation for
     * @return full path to {@code token} implementation file
     */
    private Path getFullPath(Path root, Class<?> token) {
        return root.resolve(Path.of(getPackageDir(token), getClassName(token)) + ".java");
    }

    /**
     * Compiles {@code token} implementation {@code .java} file.
     * Stores the resulting {@code .class} file at {@code path}.
     *
     * @param token type token, the implementation of which is stored at {@code temp}
     * @param path  working directory containing the source of {@code token} implementation
     * @throws ImplerException if an error occurs during compilation
     * @see JavaCompiler
     */
    private void compileJava(Class<?> token, Path path) throws ImplerException {
        String classPath = getClassPath(token);
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        String[] args = new String[]{"-cp", path + File.pathSeparator + classPath, getFullPath(path, token).toString()};
        if (compiler == null || compiler.run(null, null, null, args) != 0) {
            throw new ImplerException(EXCEPTION_COMMON + "failed to compile generated file");
        }
    }

    /**
     * Builds a {@code .jar} file containing compiled implementation of {@code token}.
     *
     * @param token   type token, the implementation of which is stored at {@code temp}
     * @param jarPath resulting {@code .jar} file destination
     * @param temp    directory containing the compiled {@code .class} files
     * @throws ImplerException if en error occurs when working with {@code .jar} file
     */
    private void createJar(Class<?> token, Path jarPath, Path temp) throws ImplerException {
        try (JarOutputStream out = new JarOutputStream(Files.newOutputStream(jarPath))) {
            String name = getPackageDir(token, "/") + "/" + getClassName(token) + ".class";
            out.putNextEntry(new ZipEntry(name));
            Files.copy(temp.resolve(name), out);
        } catch (IOException e) {
            throw new ImplerException(EXCEPTION_COMMON + "error occurred while creating jar file");
        }
    }

    /**
     * Returns whether the modifiers state that the owner token is unimplementable.
     *
     * @param modifiers modifiers bytes
     * @return true if the token is unimplementable, else false
     */
    private boolean unimplementableByModifiers(int modifiers) {
        return Modifier.isFinal(modifiers) || Modifier.isPrivate(modifiers);
    }

    /**
     * Checks if the provided token can not be implemented.
     *
     * @param token type token to check
     * @return {@code true} if the provided token can not be implemented, overwise {@code false}
     */
    private boolean unimplementable(Class<?> token) {
        return token.isPrimitive() || token.isArray()
                || unimplementableByModifiers(token.getModifiers())
                || token.equals(Enum.class);
    }

    /**
     * @return {@code String} representation of the line with the watermark
     */
    private String implementWaterMark() {
        return WATERMARK + LINE_SEPARATOR;
    }

    /**
     * @param packageName name of the package
     * @return {@code String} representation of the code line with package
     * or empty {@code String} if the name is {@code null}
     */
    private String implementPackageName(String packageName) {
        return Objects.requireNonNullElse("package " + packageName + ";" + LINE_SEPARATOR, "");
    }

    /**
     * Divides methods into abstract and final groups.
     *
     * @param methods all methods
     * @param abstractMethods where to put abstract methods
     * @param finalMethods where to put final methods
     */
    private void sortMethods(Method[] methods, Set<MethodWrapper> abstractMethods, Set<MethodWrapper> finalMethods) {
        for (Method method : methods) {
            int modifier = method.getModifiers();
            if (Modifier.isFinal(modifier)) {
                finalMethods.add(new MethodWrapper(method));
            }
            if (Modifier.isAbstract(modifier)) {
                abstractMethods.add(new MethodWrapper(method));
            }
        }
    }

    /**
     * Extracts class methods that have to be implemented.
     *
     * @param token type token of the class or interface, the child of which is being implemented
     * @return methods that have to be implemented
     */
    private List<Method> getMethodsToImplement(Class<?> token) {
        Set<MethodWrapper> abstractMethods = new HashSet<>();
        Set<MethodWrapper> finalMethods = new HashSet<>();

        sortMethods(token.getMethods(), abstractMethods, finalMethods);

        while (token != null) {
            sortMethods(token.getDeclaredMethods(), abstractMethods, finalMethods);
            token = token.getSuperclass();
        }
        abstractMethods.removeAll(finalMethods);
        return abstractMethods.stream().map(MethodWrapper::getMethod).collect(Collectors.toList());
    }

    /**
     * @param token type token of the parental class or interface
     * @return {@code String} of the format: class className Impl extends classCanonicalName
     */
    private String implementName(Class<?> token) {
        return CLASS + " " + token.getSimpleName()
                + SUFFIX + " " + (token.isInterface() ? "implements" : "extends" )
                + " " + token.getCanonicalName();
    }

    /**
     * Implements provided constructor.
     *
     * @param constructor constructor to implement
     * @param name name of the class owner of the constructor
     * @return {@code String} of the constructor implementation
     */
    private String implementConstructor(Constructor<?> constructor, String name) {
        int modifiers = constructor.getModifiers();
        return TAB + implementModifiers(modifiers) +
                name +
                implementArguments(constructor.getParameters()) +
                implementExceptions(constructor.getExceptionTypes()) +
                "{ super(" +
                Arrays.stream(constructor.getParameters())
                        .map(Parameter::getName)
                        .collect(Collectors.joining(ARG_DELIMITER)) +
                ");}" + LINE_SEPARATOR;
    }

    /**
     * Implements constructor of the given implementation of the given class or interface.
     *
     * @param token type token of the parental class or interface
     * @return {@code String} of the constructor implementation
     * @throws ImplerException if no constructors are available
     */
    private String implementConstructors(Class<?> token) throws ImplerException {
        return Arrays.stream(token.getDeclaredConstructors())
                .filter(x -> !Modifier.isPrivate(x.getModifiers()))
                .findAny()
                .map(x -> implementConstructor(x, getClassName(x.getDeclaringClass())))
                .orElseThrow(() -> new ImplerException("E Nonono!: No available constructor found"));
    }

    /**
     * @param modifiers mask of the modifiers
     * @return {@code String} representation of the implemented modifiers.
     */
    private String implementModifiers(int modifiers) {
        StringBuilder modifiersBuilder = new StringBuilder();
        if (Modifier.isPublic(modifiers)) {
            modifiersBuilder.append("public ");
        }
        if (Modifier.isProtected(modifiers)) {
            modifiersBuilder.append("protected ");
        }
        if (Modifier.isStatic(modifiers)) {
            modifiersBuilder.append("static ");
        }
        if (Modifier.isStrict(modifiers)) {
            modifiersBuilder.append("strictfp ");
        }
        if (Modifier.isFinal(modifiers)) {
            modifiersBuilder.append("final ");
        }
        return modifiersBuilder.toString();
    }

    /**
     * @param type type token of the instance that should be assigned to the default value
     * @return {@code String} representation of the default value
     */
    private String implementDefaultValue(Class<?> type) {
        if (!type.isPrimitive()) {
            return "null";
        }
        return switch (type.descriptorString()) {
            case "Z" -> "false";
            case "V" -> "";
            default -> "0";
        };
    }

    /**
     * Creates argument list
     *
     * @param argTypes arguments to implement
     * @return {@code String} representation of the implemented arguments.
     */
    private String implementArguments(Parameter[] argTypes) {
        return "(" + Arrays.stream(argTypes)
                .map(x -> x.getType().getCanonicalName() + " " + x.getName())
                .collect(Collectors.joining(ARG_DELIMITER)) + ")";
    }

    /**
     * Implements exception in the code text.
     *
     * @param exceptionTypes token type of the exception to implement
     * @return a text representation of the exception
     */
    private String implementExceptions(Class<?>[] exceptionTypes) {
        if (exceptionTypes.length == 0) {
            return "";
        }
        return "throws " + Arrays.stream(exceptionTypes).map(Class::getCanonicalName).collect(Collectors.joining(", "));
    }

    /**
     * Implements provided {@code .java} method
     *
     * @param method method to implement
     * @return {@code String} representation of the implemented method
     */
    private String implementMethod(Method method) {
        StringBuilder methodBuilder = new StringBuilder();

        int modifiers = method.getModifiers();
        if (unimplementableByModifiers(modifiers)) {
            return "";
        }
        methodBuilder.append(TAB).append(implementModifiers(modifiers));

        Class<?> returnType = method.getReturnType();
        methodBuilder.append(returnType.getCanonicalName()).append(" ");
        String defaultValue = implementDefaultValue(returnType);

        String name = method.getName();
        methodBuilder.append(name);

        Parameter[] argParams = method.getParameters();
        methodBuilder.append(implementArguments(argParams)).append("{ return ")
                .append(defaultValue).append("; }").append(LINE_SEPARATOR);
        return methodBuilder.toString();
    }

    /**
     * Command line utility for {@code Implementor}.
     * Works in two modes:
     * <ol>
     *     <li><b>java</b>: {@code <className> <outputPath>}.
     *     Creates a {@code .java} file by invoking {@link #implement(Class, Path)}.</li>
     *     <li><b>jar</b>: {@code --jar <className> <outputPath>}.
     *     Creates a {@code .jar} file by invoking {@link #implementJar(Class, Path)}.</li>
     * </ol>
     * If any of the passed arguments are invalid, execution is stopped after displaying a clarifying message.
     *
     * @param args list of command line arguments
     */
    public static void main(String[] args) {
        Objects.requireNonNull(args);
        if (args.length < 2 || args.length > 3 || args.length == 3 && !args[0].equals(JAR_MODE)) {
            System.out.println("Please read javadocs");
            return;
        }
        try {
            if (args.length == 3) {
                new Implementor().implementJar(Class.forName(Objects.requireNonNull(args[1])),
                        Paths.get(Objects.requireNonNull(args[2])));
            } else {
                new Implementor().implement(Class.forName(Objects.requireNonNull(args[0])),
                        Path.of(Objects.requireNonNull(args[1])));
            }
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (ImplerException e) {
            e.printStackTrace();
        }
    }


    /**
     * Encodes the provided {@code String}, escaping all unicode characters in {@code \\u} notation.
     * @param s {@code String} to be ecoded
     * @return encoded {@code String}
     */
    private String encode(String s) {
        StringBuilder builder = new StringBuilder();
        char[] charArray = s.toCharArray();
        for (char c : charArray) {
            if (c < 128) {
                builder.append(c);
                continue;
            }
            builder.append(String.format("\\u%04x", (int) c));
        }
        return builder.toString();
    }

}
