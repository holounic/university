## Быстрая сортировка (Сортировка Хоара)

Основанный на сравнении алгоритм сортировки, работающий за O(n log n). В худшем случае может работать за Θ(n^2), но такое случается крайне редко, а именно когда мы постоянно выбираем минимальный элемент. 

#### Алгоритм

1. Массив a[0...n] разбивается на два подмассива l = a[0...q-1] и r = a[q+1...n] так, что все элементы первой части меньше x = a[q], а все элементы второй части больше или равны ему. 

2. Подмассивы l и r рекурсивно сортируются по тому же принципу

3. Весь массив оказывается отсортированным (&#128526)

Утверждается, что примерно в 1/3 случаев мы попадем в середину аналогичного отсортированного массива и каждая часть будет <= 2/3 n. Можно улучшить время работы, если предварительно выбрать m чисел и найти их медиану. Тогда x, по которому делится массив будет гораздо ближе к середине.

```
void quickSort(int [] a, int l, int r) {
    if l < r:
        int q = partition(a, l, r)
        quickSort(a, l, q)
        quickSort(a, q, r)
}
```

Для сортировки всего массива необходимо выполнить _quickSort(a, 0, a.length - 1).

#### Разбиение 

Можно делать разбиение, выбирая каждый раз рандомный индекс.

```
int partition(int [] a, int l, int r) {
    int x = a[random() % (l - r) + r]
    int i = l
    int j = r
    while (i <= j) {
        while (a[i] < x)
            i++
        while (a[j] >= x) 
            j--;
        if (i >= j) 
            break
        swap(a[i++], a[j--])
    }
    return j
}
```

Можно улучшить спопсоб выбора опорного элемента x, считая медиану нескольких произвoльных значений.

```
int x = median(a[l], a[l+1], a[r-1])
```

#### Быстрая сортировка с разбиением на три части

Исходный массив делится на три части относително опoрного элемента x: меньше х, равные х, больше х.

```
void quickSort(int [] a, int l, int r) {
    if (r <= l)
        return

    int x = a[r]
    int i = l
    int j = r - 1
    int p = l - 1

    while (i <= j) 
        while (a[i] < x) 
           i++
        while (a[j] > x) 
           j--
        if (i >= j)
           break
        swap(a[i], a[j])
        if (a[i] == x)
           p++
           swap(a[p], a[i])
        i++
        if (a[j] == x)
           q--
           swap(a[q], a[j])
        j--
     swap(a[i], a[r])
     j = i - 1
     i++
     for (int k = l; k <= p; k++, j--) 
        swap(a[k], a[j])
     for (int k = r - 1; k >= q; k--, i++) 
        swap(a[k], a[i]) 
     quickSort(a, l, j) 
     quickSort(a, i, r)
}
```
